{"version":3,"file":"ChangeFeedForEpkRange.js","sourceRoot":"","sources":["../../../../src/client/ChangeFeed/ChangeFeedForEpkRange.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ChangeFeedRange } from \"./ChangeFeedRange\";\nimport { ChangeFeedIteratorResponse } from \"./ChangeFeedIteratorResponse\";\nimport { PartitionKeyRangeCache, QueryRange } from \"../../routing\";\nimport { FeedRangeQueue } from \"./FeedRangeQueue\";\nimport { ClientContext } from \"../../ClientContext\";\nimport { Container, Resource } from \"../../client\";\nimport { Constants, SubStatusCodes, StatusCodes, ResourceType } from \"../../common\";\nimport { Response, FeedOptions, ErrorResponse } from \"../../request\";\nimport { CompositeContinuationToken } from \"./CompositeContinuationToken\";\nimport { ChangeFeedPullModelIterator } from \"./ChangeFeedPullModelIterator\";\nimport { extractOverlappingRanges } from \"./changeFeedUtils\";\nimport { InternalChangeFeedIteratorOptions } from \"./InternalChangeFeedOptions\";\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode\";\n/**\n * @hidden\n * Provides iterator for change feed for entire container or an epk range.\n *\n * Use `Items.getChangeFeedIterator()` to get an instance of the iterator.\n */\nexport class ChangeFeedForEpkRange<T> implements ChangeFeedPullModelIterator<T> {\n  private continuationToken?: CompositeContinuationToken;\n  private queue: FeedRangeQueue<ChangeFeedRange>;\n  private startTime: string;\n  private isInstantiated: boolean;\n  private rId: string;\n  private startFromNow: boolean;\n  /**\n   * @internal\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private container: Container,\n    private partitionKeyRangeCache: PartitionKeyRangeCache,\n    private resourceId: string,\n    private resourceLink: string,\n    private url: string,\n    private changeFeedOptions: InternalChangeFeedIteratorOptions,\n    private epkRange: QueryRange,\n  ) {\n    this.queue = new FeedRangeQueue<ChangeFeedRange>();\n    this.continuationToken = changeFeedOptions.continuationToken\n      ? JSON.parse(changeFeedOptions.continuationToken)\n      : undefined;\n    this.isInstantiated = false;\n    // startTime is used to store and specify time from which change feed should start reading new changes. StartFromNow flag is used to indicate fetching changes from now.\n    if (changeFeedOptions.startFromNow) {\n      this.startFromNow = true;\n    } else if (changeFeedOptions.startTime) {\n      this.startTime = changeFeedOptions.startTime.toUTCString();\n    }\n  }\n\n  private async setIteratorRid(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    const { resource } = await this.container.readInternal(diagnosticNode);\n    this.rId = resource._rid;\n  }\n\n  private continuationTokenRidMatchContainerRid(): boolean {\n    if (this.continuationToken.rid !== this.rId) {\n      return false;\n    }\n    return true;\n  }\n\n  private async fillChangeFeedQueue(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (this.continuationToken) {\n      // fill the queue with feed ranges in continuation token.\n      await this.fetchContinuationTokenFeedRanges(diagnosticNode);\n    } else {\n      // fill the queue with feed ranges overlapping the given epk range.\n      await this.fetchOverLappingFeedRanges(diagnosticNode);\n    }\n    this.isInstantiated = true;\n  }\n\n  /**\n   * Fill the queue with the feed ranges overlapping with the given epk range.\n   */\n  private async fetchOverLappingFeedRanges(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    try {\n      const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n        this.url,\n        this.epkRange,\n        diagnosticNode,\n      );\n      for (const overLappingRange of overLappingRanges) {\n        const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n          this.epkRange,\n          overLappingRange,\n        );\n        const feedRange: ChangeFeedRange = new ChangeFeedRange(\n          overLappingRange.minInclusive,\n          overLappingRange.maxExclusive,\n          \"\",\n          epkMinHeader,\n          epkMaxHeader,\n        );\n        this.queue.enqueue(feedRange);\n      }\n    } catch (err) {\n      throw new ErrorResponse(err.message);\n    }\n  }\n  /**\n   * Fill the queue with feed ranges from continuation token\n   */\n  private async fetchContinuationTokenFeedRanges(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<void> {\n    const contToken = this.continuationToken;\n    if (!this.continuationTokenRidMatchContainerRid()) {\n      throw new ErrorResponse(\"The continuation token is not for the current container definition\");\n    } else {\n      for (const cToken of contToken.Continuation) {\n        const queryRange = new QueryRange(cToken.minInclusive, cToken.maxExclusive, true, false);\n        try {\n          const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n            this.url,\n            queryRange,\n            diagnosticNode,\n          );\n          for (const overLappingRange of overLappingRanges) {\n            // check if the epk range present in continuation token entirely covers the overlapping range.\n            // If yes, minInclusive and maxExclusive of the overlapping range will be set.\n            // If no, i.e. there is only partial overlap, epkMinHeader and epkMaxHeader are set as min and max of overlap.\n            // This will be used when we make a call to fetch change feed.\n            const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n              queryRange,\n              overLappingRange,\n            );\n            const feedRange: ChangeFeedRange = new ChangeFeedRange(\n              overLappingRange.minInclusive,\n              overLappingRange.maxExclusive,\n              cToken.continuationToken,\n              epkMinHeader,\n              epkMaxHeader,\n            );\n            this.queue.enqueue(feedRange);\n          }\n        } catch (err) {\n          throw new ErrorResponse(err.message);\n        }\n      }\n    }\n  }\n\n  /**\n   * Change feed is an infinite feed. hasMoreResults is always true.\n   */\n  get hasMoreResults(): boolean {\n    return true;\n  }\n\n  /**\n   * Gets an async iterator which will yield change feed results.\n   */\n  public async *getAsyncIterator(): AsyncIterable<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    do {\n      const result = await this.readNext();\n      yield result;\n    } while (this.hasMoreResults);\n  }\n\n  /**\n   * Gets an async iterator which will yield pages of results from Azure Cosmos DB.\n   *\n   * Keeps iterating over the feedranges and checks if any feed range has new result. Keeps note of the last feed range which returned non 304 result.\n   *\n   * When same feed range is reached and no new changes are found, a 304 (not Modified) is returned to the end user. Then starts process all over again.\n   */\n  public async readNext(): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      // validate if the internal queue is filled up with feed ranges.\n      if (!this.isInstantiated) {\n        await this.setIteratorRid(diagnosticNode);\n        await this.fillChangeFeedQueue(diagnosticNode);\n      }\n\n      // stores the last feedRange for which statusCode is not 304 i.e. there were new changes in that feed range.\n      let firstNotModifiedFeedRange: [string, string] = undefined;\n      let result: ChangeFeedIteratorResponse<Array<T & Resource>>;\n      do {\n        const [processedFeedRange, response] = await this.fetchNext(diagnosticNode);\n        result = response;\n        if (result !== undefined) {\n          {\n            if (firstNotModifiedFeedRange === undefined) {\n              firstNotModifiedFeedRange = processedFeedRange;\n            }\n            // move current feed range to end of queue to fetch result of next feed range.\n            // This is done to fetch changes in breadth first manner and avoid starvation.\n            this.queue.moveFirstElementToTheEnd();\n            // check if there are new results for the given feed range.\n            if (result.statusCode === StatusCodes.Ok) {\n              result.headers[Constants.HttpHeaders.ContinuationToken] =\n                this.generateContinuationToken();\n              return result;\n            }\n          }\n        }\n      } while (!this.checkedAllFeedRanges(firstNotModifiedFeedRange));\n      // set the continuation token after processing.\n      result.headers[Constants.HttpHeaders.ContinuationToken] = this.generateContinuationToken();\n      return result;\n    }, this.clientContext);\n  }\n\n  private generateContinuationToken = (): string => {\n    return JSON.stringify(new CompositeContinuationToken(this.rId, this.queue.returnSnapshot()));\n  };\n\n  /**\n   * Read feed and retrieves the next page of results in Azure Cosmos DB.\n   */\n  private async fetchNext(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<[[string, string], ChangeFeedIteratorResponse<Array<T & Resource>>]> {\n    const feedRange = this.queue.peek();\n    if (feedRange) {\n      // fetch results for feed range at the beginning of the queue.\n      const result = await this.getFeedResponse(feedRange, diagnosticNode);\n\n      // check if results need to be fetched again depending on status code returned.\n      // Eg. in case of paritionSplit, results need to be fetched for the child partitions.\n      const shouldRetry: boolean = await this.shouldRetryOnFailure(\n        feedRange,\n        result,\n        diagnosticNode,\n      );\n\n      if (shouldRetry) {\n        this.queue.dequeue();\n        return this.fetchNext(diagnosticNode);\n      } else {\n        // update the continuation value for the current feed range.\n        const continuationValueForFeedRange = result.headers[Constants.HttpHeaders.ETag];\n        const newFeedRange = this.queue.peek();\n        newFeedRange.continuationToken = continuationValueForFeedRange;\n\n        return [[newFeedRange.minInclusive, newFeedRange.maxExclusive], result];\n      }\n    } else {\n      return [[undefined, undefined], undefined];\n    }\n  }\n\n  private checkedAllFeedRanges(firstNotModifiedFeedRange: [string, string]): boolean {\n    if (firstNotModifiedFeedRange === undefined) {\n      return false;\n    }\n    const feedRangeQueueFirstElement = this.queue.peek();\n    return (\n      firstNotModifiedFeedRange[0] === feedRangeQueueFirstElement?.minInclusive &&\n      firstNotModifiedFeedRange[1] === feedRangeQueueFirstElement?.maxExclusive\n    );\n  }\n\n  /**\n   * Checks whether the current EpkRange is split into multiple ranges or not.\n   *\n   * If yes, it force refreshes the partitionKeyRange cache and enqueue children epk ranges.\n   */\n  private async shouldRetryOnFailure(\n    feedRange: ChangeFeedRange,\n    response: ChangeFeedIteratorResponse<Array<T & Resource>>,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<boolean> {\n    if (response.statusCode === StatusCodes.Ok || response.statusCode === StatusCodes.NotModified) {\n      return false;\n    }\n\n    const partitionSplit =\n      response.statusCode === StatusCodes.Gone &&\n      (response.subStatusCode === SubStatusCodes.PartitionKeyRangeGone ||\n        response.subStatusCode === SubStatusCodes.CompletingSplit);\n\n    if (partitionSplit) {\n      const queryRange = new QueryRange(\n        feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive,\n        feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive,\n        true,\n        false,\n      );\n      const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n        this.url,\n        queryRange,\n        diagnosticNode,\n        true,\n      );\n      if (resolvedRanges.length < 1) {\n        throw new ErrorResponse(\"Partition split/merge detected but no overlapping ranges found.\");\n      }\n      // This covers both cases of merge and split.\n      // resolvedRanges.length > 1 in case of split.\n      // resolvedRanges.length === 1 in case of merge. EpkRange headers will be added in this case.\n      if (resolvedRanges.length >= 1) {\n        await this.handleSplit(false, resolvedRanges, queryRange, feedRange.continuationToken);\n      }\n      return true;\n    }\n    return false;\n  }\n  /*\n   * Enqueues all the children feed ranges for the given feed range.\n   */\n  private async handleSplit(\n    shiftLeft: boolean,\n    resolvedRanges: any,\n    oldFeedRange: QueryRange,\n    continuationToken: string,\n  ): Promise<void> {\n    let flag = 0;\n    if (shiftLeft) {\n      // This section is only applicable when handleSplit is called by getPartitionRangeId().\n      // used only when existing partition key range cache is used to check for any overlapping ranges.\n      // Modifies the first element with the first overlapping range.\n      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n        oldFeedRange,\n        resolvedRanges[0],\n      );\n      const newFeedRange = new ChangeFeedRange(\n        resolvedRanges[0].minInclusive,\n        resolvedRanges[0].maxExclusive,\n        continuationToken,\n        epkMinHeader,\n        epkMaxHeader,\n      );\n\n      this.queue.modifyFirstElement(newFeedRange);\n      flag = 1;\n    }\n    // Enqueue the overlapping ranges.\n    for (let i = flag; i < resolvedRanges.length; i++) {\n      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n        oldFeedRange,\n        resolvedRanges[i],\n      );\n      const newFeedRange = new ChangeFeedRange(\n        resolvedRanges[i].minInclusive,\n        resolvedRanges[i].maxExclusive,\n        continuationToken,\n        epkMinHeader,\n        epkMaxHeader,\n      );\n      this.queue.enqueue(newFeedRange);\n    }\n  }\n\n  /**\n   * Fetch the partitionKeyRangeId for the given feed range.\n   *\n   * This partitionKeyRangeId is passed to queryFeed to fetch the results.\n   */\n  private async getPartitionRangeId(\n    feedRange: ChangeFeedRange,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<string> {\n    const min = feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive;\n    const max = feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive;\n    const queryRange = new QueryRange(min, max, true, false);\n    const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n      this.url,\n      queryRange,\n      diagnosticNode,\n      false,\n    );\n    if (resolvedRanges.length < 1) {\n      throw new ErrorResponse(\"No overlapping ranges found.\");\n    }\n    const firstResolvedRange = resolvedRanges[0];\n    if (resolvedRanges.length > 1) {\n      await this.handleSplit(true, resolvedRanges, queryRange, feedRange.continuationToken);\n    }\n    return firstResolvedRange.id;\n  }\n\n  private async getFeedResponse(\n    feedRange: ChangeFeedRange,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    const feedOptions: FeedOptions = {\n      initialHeaders: {},\n      useLatestVersionFeed: true,\n      useAllVersionsAndDeletesFeed: false,\n    };\n\n    if (typeof this.changeFeedOptions.maxItemCount === \"number\") {\n      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;\n    }\n\n    if (this.changeFeedOptions.sessionToken) {\n      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;\n    }\n\n    if (feedRange.continuationToken) {\n      feedOptions.accessCondition = {\n        type: Constants.HttpHeaders.IfNoneMatch,\n        condition: feedRange.continuationToken,\n      };\n    } else if (this.startFromNow) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfNoneMatch] =\n        Constants.ChangeFeedIfNoneMatchStartFromNowHeader;\n    }\n\n    if (this.startTime) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.startTime;\n    }\n\n    if (\n      this.changeFeedOptions.changeFeedMode &&\n      this.changeFeedOptions.changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes\n    ) {\n      feedOptions.useAllVersionsAndDeletesFeed = true;\n      feedOptions.useLatestVersionFeed = false;\n    }\n\n    const rangeId = await this.getPartitionRangeId(feedRange, diagnosticNode);\n    try {\n      // startEpk and endEpk are only valid in case we want to fetch result for a part of partition and not the entire partition.\n      const response: Response<Array<T & Resource>> = await (this.clientContext.queryFeed<T>({\n        path: this.resourceLink,\n        resourceType: ResourceType.item,\n        resourceId: this.resourceId,\n        resultFn: (result) => (result ? result.Documents : []),\n        query: undefined,\n        options: feedOptions,\n        diagnosticNode,\n        partitionKey: undefined,\n        partitionKeyRangeId: rangeId,\n        startEpk: feedRange.epkMinHeader,\n        endEpk: feedRange.epkMaxHeader,\n      }) as Promise<any>);\n\n      return new ChangeFeedIteratorResponse(\n        response.result,\n        response.result ? response.result.length : 0,\n        response.code,\n        response.headers,\n        getEmptyCosmosDiagnostics(),\n      );\n    } catch (err) {\n      if (err.code >= StatusCodes.BadRequest && err.code !== StatusCodes.Gone) {\n        const errorResponse = new ErrorResponse(err.message);\n        errorResponse.code = err.code;\n        errorResponse.headers = err.headers;\n\n        throw errorResponse;\n      }\n\n      // If any other errors are encountered, eg. partition split or gone, handle it based on error code and not break the flow.\n      return new ChangeFeedIteratorResponse(\n        [],\n        0,\n        err.code,\n        err.headers,\n        getEmptyCosmosDiagnostics(),\n        err.substatus,\n      );\n    }\n  }\n}\n"]}