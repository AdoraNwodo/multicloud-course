{"version":3,"file":"NonStreamingOrderByEndpointComponent.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/EndpointComponent/NonStreamingOrderByEndpointComponent.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { Response } from \"../../request\";\nimport { ExecutionContext } from \"../ExecutionContext\";\nimport { OrderByComparator } from \"../orderByComparator\";\nimport { NonStreamingOrderByResult } from \"../nonStreamingOrderByResult\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue\";\nimport { getInitialHeader } from \"../headerUtils\";\n\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by query.\n */\nexport class NonStreamingOrderByEndpointComponent implements ExecutionContext {\n  /**\n   * A priority queue to store the final sorted results.\n   */\n  private nonStreamingOrderByPQ: FixedSizePriorityQueue<NonStreamingOrderByResult>;\n  /**\n   * Flag to determine if all results are fetched from backend and results can be returned from priority queue.\n   */\n  private isCompleted: boolean = false;\n  /**\n   * Represents an endpoint in handling an non-streaming order by query. For each processed orderby\n   * result it returns 'payload' item of the result\n   *\n   * @param executionContext - Underlying Execution Context\n   * @hidden\n   */\n  constructor(\n    private executionContext: ExecutionContext,\n    private sortOrders: any[],\n    private priorityQueueBufferSize: number,\n    private offset: number = 0,\n  ) {\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(b, a);\n      },\n      this.priorityQueueBufferSize,\n    );\n  }\n\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders,\n      };\n    }\n\n    // If there are more results in backend, keep filling pq.\n    if (this.executionContext.hasMoreResults()) {\n      const { result: item, headers } = await this.executionContext.nextItem(diagnosticNode);\n      resHeaders = headers;\n      if (item !== undefined) {\n        this.nonStreamingOrderByPQ.enqueue(item);\n      }\n\n      // If the backend has more results to fetch, return {} to signal that there are more results to fetch.\n      if (this.executionContext.hasMoreResults()) {\n        return {\n          result: {},\n          headers: resHeaders,\n        };\n      }\n    }\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      // Set isCompleted to true.\n      this.isCompleted = true;\n      // Reverse the priority queue to get the results in the correct order\n      this.nonStreamingOrderByPQ = this.nonStreamingOrderByPQ.reverse();\n      // For offset limit case we set the size of priority queue to offset + limit\n      // and we drain offset number of items from the priority queue\n      while (\n        this.offset < this.priorityQueueBufferSize &&\n        this.offset > 0 &&\n        !this.nonStreamingOrderByPQ.isEmpty()\n      ) {\n        this.nonStreamingOrderByPQ.dequeue();\n        this.offset--;\n      }\n    }\n    // If pq is not empty, return the result from pq.\n    if (!this.nonStreamingOrderByPQ.isEmpty()) {\n      const item = this.nonStreamingOrderByPQ.dequeue()?.payload;\n      return {\n        result: item,\n        headers: resHeaders,\n      };\n    }\n    // If pq is empty, return undefined to signal that there are no more results.\n    return {\n      result: undefined,\n      headers: resHeaders,\n    };\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs.\n   * @returns true if there is other elements to process in the NonStreamingOrderByEndpointComponent.\n   */\n  public hasMoreResults(): boolean {\n    return (\n      this.priorityQueueBufferSize > 0 &&\n      (this.executionContext.hasMoreResults() || !this.nonStreamingOrderByPQ.isEmpty())\n    );\n  }\n}\n"]}